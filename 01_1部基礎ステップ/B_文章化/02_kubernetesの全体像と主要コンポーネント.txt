■Kubernetes の全体像と主要コンポーネント　― 分散した実行単位を成立させ続けるという話 ―

節タイトル一覧
1.コンテナが増えた世界で何が問題になったのか
2.Kubernetes は何を解決しようとしているのか
3.人が操作しないという設計思想
4.Kubernetes の全体像 ― Control Plane と Node の役割
5.主要コンポーネントは何を担当しているのか
6.Kubernetes は OS ではない
7.この章のまとめ ― 次に見える問題

1. コンテナが増えた世界で何が問題になったのか
第1章で見てきたように、
コンテナによってアプリケーションは
「環境から切り離された実行単位」として扱えるようになりました。

これは大きな前進でしたが、同時に新しい問題を生みます。

・実行単位が増える
・実行場所が固定されない
・いつ壊れるか分からない

単体では正しく動くアプリケーションも、数が増え、場所が分散すると、
全体としては簡単に破綻するようになります。

ここで直面したのは、「どう作るか」ではなく、
増え続ける単位を誰が、どうやって、成立させ続けるのか
という問題でした。

人が一つ一つ状態を確認し、必要に応じて操作する。
このやり方は、単位が少ないうちは機能します。

しかし、コンテナの世界ではこの前提がすぐに崩れます。


2.Kubernetes は何を解決しようとしているのか
Kubernetes は、「コンテナを動かすためのツール」ではありません。

Kubernetes が向き合っているのは、分散した実行単位を
人の手によらず、全体として成立させ続けることです。

そのために Kubernetes が行っているのは、

・コンテナの起動手順を覚えること
・サーバーを管理すること

ではありません。

Kubernetes が扱うのは、「あるべき状態」 です。

たとえば、

・このアプリケーションは何個動いていてほしいのか
・どこで動いていてほしいのか
・壊れたとき、どう戻っていてほしいのか

といった 状態の定義 を受け取り、それが成立するように動き続けます。

逆に言えば、

・アプリケーションの中身
・ビジネスロジック
・実装の詳細

といったものは、Kubernetesの責任範囲ではありません。

ここを切り分けて考えることが、Kubernetesを理解する最初のポイントです。


3.人が操作しないという設計思想
Kubernetes を初めて触った人が
戸惑う点の一つに、「なぜ直接操作しないのか」
という疑問があります。

従来の運用では、

・起動する
・停止する
・再起動する

といった 操作 が中心でした。

しかし、分散した環境ではこのやり方は長く持ちません。

なぜなら、

・状態は常に変わる
・操作した直後に別の変化が起こる
・人が追いかけられない

からです。

そこで Kubernetes は、操作ではなく状態を宣言するという設計を採ります。

「こうしてほしい」ではなく、「こういう状態であってほしい」
を伝え続ける。

Kubernetesは、現在の状態と理想の状態を常に比較し、
その差分を自動的に埋め続けます。

ここで重要なのは、人が賢くなる必要はないという点です。
賢くなるべきなのは、仕組みの側です。


4.Kubernetes の全体像 ― ControlPlaneとNodeの役割
― Control Plane と Node の役割 ―

この考え方を実現するために、Kubernetes は明確な役割分担を持っています。
大きく分けると、

・ControlPlane
・Node（Worker Node）

の二つです。

ControlPlane は、「こうあるべき状態」を理解し、
それを成立させるための判断を行います。

一方で Node は、実際にコンテナを動かす場所です。

ここで注意したいのは、ControlPlaneがNodeに対して
「命令」しているわけではないという点です。

Kubernetesの設計では、

・状態は API を通じて共有される
・各コンポーネントはその状態を見て、自律的に動く

という前提が置かれています。

この構造によって、

・一部が壊れても
・全体が止まらず
・状態が戻り続ける

という性質が生まれます。


5.主要コンポーネントは何を担当しているのか
Kubernetes には、複数の主要コンポーネントが存在します。

ここで大切なのは、名前を覚えることではありません。
見るべきなのは、「なぜこの分担になっているのか」です。

・APIServerは、状態の窓口として振る舞います
・Schedulerは、実行場所を決めます
・Controllerは、状態がずれたときに戻します
・kubeletは、Node上で状態を成立させます

それぞれが一つの責務だけを持ち、それ以上のことをしません。

この分離によって、

・一部が壊れても
・他が代わりに動き
・全体として成立し続ける

という構造が保たれます。

ここでも、「便利だから増えた機能」ではなく、
壊れ続ける世界に耐えるための分割であることが重要です。


6.Kubernetes は OS ではない
Kubernetes は、しばしば「分散OS」と表現されることがあります。

この言い方が生まれる理由は理解できますが、そのまま受け取ると誤解を生みます。

Kubernetes は、

・ハードウェアを管理しない
・プロセスを直接制御しない
・ネットワークを抽象化しきらない

という点で、OSとは役割が異なります。

この違いは、次章以降でLinuxやネットワークの話と接続することで
よりはっきりします。

（※ ここは第4章を書いた後で言い切り方を最終調整する想定です）


7. この章のまとめ ― 次に見える問題
▼次章への橋渡し
・単位は切れた
・制御もできるようになった
・では「どこで動かすか」はどう考える？

第3章（クラウド／オンプレ）への必然的接続


▲内部ルール
・マニフェストは出さない
・YAML は書かない
・kubectl コマンドは出さない
・数値・性能比較はしない
・常に「なぜこの設計なのか」に戻る


第1章との対応関係（確認）

| 第1章（コンテナ）    | 第2章（Kubernetes）  |
| -------------------- | ---------------------|
| 実行単位の再定義     | 実行単位の制御       |
| 環境からの分離       | 人からの分離         |
| 単位が切れた         | 単位が増えた         |
| Docker の位置づけ    | Kubernetes の位置づけ|
