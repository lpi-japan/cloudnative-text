■Linux / ネットワークの基本整理　― すべての前提になっている足場を言葉にする ―

節タイトル一覧（一覧用）
1.なぜ今さら Linux とネットワークなのか
2.Linux は何を提供している OS なのか
3.コンテナが Linux 前提である理由
4.ネットワークは「つながる」より「切れる」が前提
5.分散システムにおける失敗の扱い方
6.OS / ネットワークの制約を、誰が引き受けているのか
7.この章のまとめ ― 前提を知ると設計は自由になる


1. なぜ今さら Linux とネットワークなのか
クラウドや Kubernetes の話をしていると、Linux やネットワークは
「その下で勝手に動いているもの」として扱われがちです。

実際、多くの場面では細かい挙動を意識しなくても
システムは動いてしまいます。
しかし、それは前提が消えたのではなく、隠れただけ です。

・コンテナがなぜ軽いのか
・Kubernetes がなぜその制御をしているのか
・ネットワーク障害がなぜ避けられないのか

これらはすべて、OSとネットワークの性質に根ざしています。

この章では、「知っているはずだった前提」を
あらためて言葉に戻します。


2.Linux は何を提供している OS なのか
Linuxというと、コマンド操作や設定ファイルを思い浮かべる人も多いかもしれません。
しかし、本質的に Linux が提供しているのは、

計算資源と境界の管理になります。

Linuxには

・CPU
・メモリ
・ディスク
・ネットワーク

といった資源をプロセス単位で分配し、互いに影響しないよう
境界を引きます。

ここで重要なのは、Linuxはアプリケーションを
「守ってくれる存在」ではない、という点です。

Linuxは、

・どこまで使ってよいか
・どこまで見えてよいか

を決めるだけで、正しく動くかどうかには関与しません。

この性質があるからこそ、上位の仕組みが
役割を分担できる余地が生まれます。


3.コンテナが Linux 前提である理由
第1章で見たコンテナは、まったく新しい実行環境に見えるかもしれません。

しかし実際には、コンテナはLinuxの機能の組み合わせによって
成立しています。

・プロセスを分ける
・見える範囲を制限する
・使える資源を制御する

これらはすべて、Linux が元々持っていた仕組みです。

つまりコンテナは、
OSを仮想化したものではなく
OSの使い方を変えたものだと言えます。

このため、コンテナは「軽い」のではなく、
余計なものを最初から持たないという性質を持ちます。

ここを理解すると、なぜコンテナが実行単位として扱いやすいのかが
構造として見えてきます。


4.ネットワークは「つながる」より「切れる」が前提
単一のマシンで動くプログラムでは、ネットワークは
ほとんど意識されません。
しかし、分散システムでは話が変わります。

ネットワークには、ある種の避けられない性質があります。

・遅延する
・順序が入れ替わる
・突然切れる

これらは例外ではなく前提条件です。

重要なのは、ネットワークが「不安定」なのではなく、
制御できない要素を含んでいるという点です。

この前提に立つと、

・タイムアウト
・再試行
・冪等性

といった考え方が、単なるテクニックではなく
設計上の必然として見えてきます。


5.分散システムにおける失敗の扱い方
ネットワーク越しに複数のコンポーネントが連携する以上、
部分的な失敗は避けられません。

・片方は動いている
・もう片方は止まっている
・状態が一時的にずれる

この状況を「異常」として排除しようとすると、
設計は破綻します。

代わりに必要なのは、

失敗を前提に、戻れる構造を作る
という考え方です。

Kubernetes が、

・常に状態を見続ける
・ずれを検知する
・自動的に戻す

という設計を採っているのは、この前提があるからです。


6.OS / ネットワークの制約を、誰が引き受けているのか
ここまでの話を整理すると、次の問いが浮かびます。

OSやネットワークの制約は誰が引き受けているのか？

・アプリケーションが直接引き受ける部分
・Kubernetes が肩代わりしている部分
・クラウドが隠している部分

これらは明確に分かれているわけではありません。

しかし、どこかが必ず引き受けているという点は変わりません。

この責任の所在を意識できるようになると、
「なぜこの設定が必要なのか」
「なぜここは任せてよいのか」
という判断が可能になります。


7.この章のまとめ ― 前提を知ると設計は自由になる
▼1部の締め
・前提を知らないと選択肢は狭まる
・前提を理解すると判断できる
・第1部で揃ったものの再確認

第2部へ進むための認知の整理

▲内部ルール
・コマンド例は出さない
・設定ファイルは出さない
・プロトコル詳細には踏み込まない
・「なぜその制約があるか」に集中する

第1部 全体の対応関係（最終確認）
|   章  | 揃えている認知  |
| ------| --------------- |
| 第1章 | 実行単位        |
| 第2章 | 制御の仕組み    |
| 第3章 | 実行環境        |
| 第4章 | 前提条件（基盤）|


