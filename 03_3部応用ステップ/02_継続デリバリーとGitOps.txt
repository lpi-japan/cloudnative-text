継続的デリバリーと GitOps

■この章で扱うこと

前章では、アプリケーションをどのような単位で分けるか、
という設計上の判断を扱いました。

しかし、アプリケーションを分けただけでは、
システムは運用できません。

分割されたアプリケーションは、
・繰り返し変更され
・更新され
・環境に反映され続ける
必要があります。

この章では、この「変更を届け続ける」という課題を、
継続的デリバリーという観点から整理します。

ここでの目的は、特定のツールを使えるようになることではありません。

なぜ、現在のクラウドネイティブな環境ではこのようなデリバリーの形が
前提になっているのかを理解することが、この章のゴールです。


1. 「一度デプロイすれば終わり」ではなくなった理由
従来のシステムでは、デプロイは「イベント」でした。

・リリース日を決め
・手順を確認し
・問題が起きないことを祈りながら反映する

このやり方は、変更頻度が低く、
影響範囲も限定的な環境では成立していました。

しかし、アプリケーションが分割され、変更の単位が小さくなると、
この前提は崩れます。

・小さな変更が頻繁に発生する
・すべてを人手で管理できなくなる
・「誰が、いつ、何を変えたか」が重要になる

ここから、変更を前提とした運用 が必要になります。


2. 継続的デリバリーとは「自動化」ではない
継続的デリバリーという言葉は、しばしば「自動デプロイ」と同一視されます。
しかし、本質はそこではありません。

継続的デリバリーが目指しているのは、
変更を、いつでも安全に環境へ反映できる状態を保つことです。

そのために必要なのは、
・変更内容が明確であること
・変更手順が再現可能であること
・問題が起きたときに、元に戻せること
つまり、人が頑張らなくても成立する状態 を作ることです。


3. なぜ「人が直接デプロイしない」構造になるのか
クラウドネイティブな環境では、デプロイを人の操作に依存させない構造が
一般的になっています。

これは、人が信用できないからではありません。
理由はもっと単純で、

・人の操作は記録が残りにくい
・手順が微妙に変わりやすい
・再現性を保つのが難しい

からです。

変更が頻繁に発生する状況では、
「誰がやったか」より「何が行われたか」 が重要になります。

そのため、デプロイという行為そのものを、人の手から切り離す設計が選ばれます。


4. GitOpsという考え方
GitOps は、この課題に対する一つの整理の仕方です。

GitOps では、
・環境のあるべき状態を Git に定義し
・実際の環境を、その状態に近づけ続ける
という構造を取ります。

ここで重要なのは、Git が特別だからではありません。
Git が選ばれている理由は、

・変更履歴が残る
・差分が明確になる
・レビューや承認ができる

といった特性が、「変更を扱う」ことに向いている からです。

GitOpsは、ツールや製品の名前ではなく、変更管理の考え方だと捉えると理解しやすくなります。


5. Kubernetes と GitOps の関係
Kubernetes は、「あるべき状態」を宣言的に定義できる基盤です。

・望ましい状態を記述し
・実際の状態との差分を調整する

この特性は、GitOps の考え方と非常に相性が良い。

そのため、Git に定義された状態をもとにKubernetesの状態を同期させる、
という構造が自然に成立します。

ここで重要なのは、Kubernetes が GitOps を要求しているわけではない
という点です。

あくまで、
・変更頻度が高く
・状態をコードとして扱える
という前提のもとで、GitOps という考え方が有効になったという関係です。


6. 継続的デリバリーは「判断を減らす仕組み」である
継続的デリバリーや GitOps は、人の判断を増やすための仕組みではありません。
むしろ逆で、人が毎回判断しなくても済むようにするための仕組みです。

・何を変更するか
・どの状態が正しいか
・いつ反映されるか

これらをあらかじめ構造として固定することで、
運用時の迷いを減らします。

この章で扱ったのは、そのための 前提条件の整理 です。

7. GitOpsを「引き受ける存在」として見る
― Argo CD と Flux の役割 ―

ここまでで整理してきた GitOps の構造は、「あるべき状態を Git に定義し、
実際の環境をその状態に近づけ続ける」というものでした。

Argo CD と Flux は、この構造を Kubernetes 上で成立させるために、
人が行っていた判断や作業の一部を引き受ける存在です。

重要なのは、それぞれが どの責務を引き受けているか という視点です。


▼Argo CD が引き受けているもの
Argo CD は、「環境の状態をどう見るか、どう判断するか」
という責務を強く引き受けます。

Git に定義された状態と実際のクラスタの状態を比較し
その差分を、人が理解できる形で表現する

Argo CD が担っているのは、状態の可視化と判断の補助です。

その結果、
・いま何が起きているのか
・どこまでが意図された変更なのか
を、人が把握しやすくなります。


▼Flux が引き受けているもの
Flux は、「あるべき状態へ近づけ続ける」という動作そのもの
を淡々と引き受けます。

状態を定義し、差分があれば反映し、それを繰り返す

Flux が担っているのは、同期を回し続けるという運用の自動化 です。

ここでは、
・状態をどう見せるか
・人がどう判断するか
よりも、仕組みとして回り続けること が中心になります。


▼役割の違いを一段抽象化すると

Argo CD と Flux の違いは、優劣の話ではありません。

・Argo CD：状態をどう理解し、どう判断するかを引き受ける
・Flux　 ：状態をどう同期し続けるかを引き受ける

どちらも GitOps の構造を成立させる存在ですが、
人との関わり方の重心が異なると言えます。


■この章のまとめ ― 「届け続ける」ための前提

この章では、
・変更が前提になった環境では
・人の操作に依存しない形で
・状態を管理する必要がある
という点を整理しました。

継続的デリバリーや GitOps は、そのための代表的な考え方です。
ここでは、「どのツールを使うか」を決める必要はありません。

大切なのは、変更をどう扱うか、という前提を設計として持てているかです。

アプリケーションを分け、変更を届ける構造を整えると、次に避けて通れない問題があります。
分割されたサービス同士は、どのようにつながり、その通信を誰が制御するのか

次の章では、この問いをサービス間通信制御 という観点から扱います。