サービス間通信制御
— 複雑さを、どこで引き受けるか —

■この章で扱うこと
前章までで、アプリケーションを分け、それを継続的に届けるための前提を整理しました。
しかし、アプリケーションを分割した瞬間から、避けて通れない問題が現れます。

分割されたサービス同士は、どのようにつながり、その通信を誰が制御するのか
この章では、この問いを サービス間通信制御 という観点から扱います。

ここでの目的は、特定の技術を導入することではありません。

通信に関する複雑さを、どこで引き受ける設計なのかを意識できるようになることが、
この章のゴールです。


1. 分割された瞬間に、通信は「設計課題」になる
単一のアプリケーションの中では、通信はほとんど意識されません。

・関数を呼び
・処理を行い
・結果を返す

しかし、アプリケーションを分割すると、
この流れはネットワーク越しの通信に変わります。

・到達しない可能性
・遅延が発生する可能性
・相手が応答しない可能性

通信は、失敗する前提を持つようになります。
この瞬間から、通信は実装の詳細ではなく、設計として扱うべき対象 になります。


2. 通信制御は「どこかで必ず行われている」
サービス間通信を「制御しない」という選択肢は存在しません。

意識していなくても、
・タイムアウト
・リトライ
・エラーハンドリング
といった判断は、必ずどこかで行われています。

問題は、それをどこで引き受けているか です。
・各サービスのコードなのか
・共通ライブラリなのか
・基盤側なのか

通信制御は、すでに存在しています。
ただ、見えていないだけ です。


3. アプリケーション側で制御するという選択
通信制御をアプリケーション側で引き受ける方法は、もっとも素朴な形です。

・各サービスがリトライを実装する
・タイムアウトやエラー処理を持つ
・挙動をコードで明示する
この方法の利点は、振る舞いが分かりやすい ことです。

一方で、

・同じような実装が増える
・振る舞いの統一が難しくなる
・変更時の影響範囲が広がる

といった側面も持ちます。

重要なのは、この選択がどの複雑さを引き受けているか
を理解しているかどうかです。


4. 基盤側で制御するという選択
通信制御を基盤側で引き受ける、という考え方もあります。

・通信の振る舞いを共通化する
・各サービスのコードから制御を切り離す
・運用時に振る舞いを調整しやすくする

この文脈で、サービスメッシュという考え方が現れます。

ただし、ここで注意が必要です。サービスメッシュは目的ではありません。
それは、通信制御を基盤側に寄せるための一つの実現手段 にすぎません。


5. 複雑さは「消える」のではなく「移動する」
通信制御をアプリケーション側から基盤側へ移すと、
コードは確かにシンプルになります。

しかし、複雑さが消えるわけではありません。

・設定の理解
・振る舞いの可視化
・障害時の切り分け

といった別の形で、複雑さが現れます。

つまり、通信制御の設計とは、複雑さをなくすことではなく、
どこに置くかを決めることです。


6. 「導入するか」ではなく「引き受けられるか」
この章で扱っている問いは、
「サービスメッシュを導入するかどうか」ではありません。

本質的な問いは、次の点にあります。
・この通信制御の複雑さを、誰が理解するのか
・障害時に、どこまで追えるのか
・組織として、引き受けきれるのか

技術的に可能であることと、
組織として引き受けられることは、
この2つは必ずしも一致しません。


7. 通信制御を「引き受ける存在」として見る
― Istio と Linkerd の役割 ―

ここまでで整理してきた通信制御の考え方は、
「通信に関する判断を、どこで引き受けるか」
というものでした。

Istio や Linkerd は、この判断の一部を
基盤側で引き受けるための仕組みです。

重要なのは、それらが 何を引き受けているか という視点です。

▼Istio が引き受けているもの
Istio は、サービス間通信に関する振る舞いを、
明示的に定義し、制御する責務 を引き受けます。

・通信ポリシーをどう定義するか
・失敗時にどう振る舞うか
・通信経路をどう制御するか

といった判断を、アプリケーションコードの外に切り出します。

Istio が引き受けているのは、
通信に関する「判断」と「制御」を仕組みとして表現する役割
だと捉えることができます。
　
※本書でいう「通信に関する判断と制御」とは、どの通信を許可するか、
　失敗時にどう振る舞うか、どこまで待つか、問題が起きた際にどこで止め、
　誰がそれを把握すべきか、といった通信の振る舞いを事前に定義し、
　実行時に適用する一連の決定を指します。

その分、設定や構造を理解する責任も引き受けることになります。

▼Linkerd が引き受けているもの
Linkerd は、サービス間通信を安定して成立させ続けること
に重心を置いています。

・通信の健全性を保つ
・失敗しやすい状況を緩和する
・基本的な通信制御を共通化する

Linkerd が引き受けているのは、
通信を「意識しなくても回り続ける」状態に近づけることです。

※ 本書でいう「通信を意識しなくても回り続ける状態」とは、
　 個々のサービスが通信の失敗や遅延を強く意識せずとも、
　 基本的な再試行や安定化の仕組みによって、
　 サービス間通信が破綻しにくい状態が保たれていることを指します。

ここでは、
・複雑な判断を多く持たず
・運用負荷を抑える
という方向性が取られます。


▼役割の違いを一段抽象化すると
Istio と Linkerd の違いは、機能の多寡や優劣ではありません。

・Istio　：通信に関する 判断と制御を明示的に引き受ける
・Linkerd：通信を 安定して成立させ続けることを引き受ける

どちらも、通信制御を基盤側に寄せる選択肢ですが、
引き受けている責務の重さと種類が異なると捉えることができます。


■この章のまとめ ― 通信は「判断の集まり」である
サービス間通信は、単なるデータのやり取りではありません。

・失敗をどう扱うか
・遅延をどう許容するか
・どこまでを共通化するか

といった 判断の集まり です。

Istio や Linkerd は、その判断の一部を
基盤側で引き受ける存在です。

この章で大切なのは、どの名前を選ぶかではありません。
通信制御を、意識的な設計判断として捉えられているかです。